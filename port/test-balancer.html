<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balancer System Test</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-section {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #ccc;
            background: #f5f5f5;
        }
        .test-section h3 {
            margin-top: 0;
        }
        .pass {
            color: green;
        }
        .fail {
            color: red;
        }
        pre {
            background: white;
            padding: 10px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Balancer System Test</h1>
    <div id="results"></div>

    <script src="balancer.js"></script>
    <script>
        const results = [];
        
        function test(name, fn) {
            try {
                const result = fn();
                if (result) {
                    results.push({ name, status: 'pass', message: result });
                } else {
                    results.push({ name, status: 'fail', message: 'Test returned false' });
                }
            } catch (e) {
                results.push({ name, status: 'fail', message: e.message, error: e });
            }
        }
        
        function assertEquals(actual, expected, message) {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                throw new Error(`${message}: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
            }
            return message;
        }
        
        function assertNotNull(value, message) {
            if (value === null || value === undefined) {
                throw new Error(`${message}: value is null or undefined`);
            }
            return message;
        }
        
        function assertGreaterThan(value, threshold, message) {
            if (value <= threshold) {
                throw new Error(`${message}: ${value} is not greater than ${threshold}`);
            }
            return message;
        }

        function assertInstanceOf(value, constructor, message) {
            if (!(value instanceof constructor)) {
                throw new Error(`${message}: value is not an instance of ${constructor.name}`);
            }
            return message;
        }

        function assertThrows(fn, message) {
            try {
                fn();
                throw new Error(`${message}: function did not throw`);
            } catch (e) {
                // Expected to throw
                return message;
            }
        }

        // ====================================================================
        // Helper functions
        // ====================================================================

        /**
         * Count splitters and mergers in a graph
         * @param {string} graph_source - string representation of the graph
         * @returns {Array} [splitters, mergers]
         */
        function count_devices(graph_source) {
            const splitter_matches = graph_source.match(/S\d+/g);
            const merger_matches = graph_source.match(/M\d+/g);
            const splitters = splitter_matches ? new Set(splitter_matches).size : 0;
            const mergers = merger_matches ? new Set(merger_matches).size : 0;
            return [splitters, mergers];
        }

        // ====================================================================
        // Tests ported from test_balancer.py
        // ====================================================================

        test('test_basic_split: basic 3-way split', () => {
            const g = design_balancer([100], [40, 30, 30]);
            const [s, m] = count_devices(g.source);
            if (s !== 1 || m !== 0) {
                throw new Error(`Expected 1S + 0M, got ${s}S + ${m}M`);
            }
            return 'Basic split test: 1 splitter, 0 mergers';
        });

        test('test_basic_merge: basic 3-way merge', () => {
            const g = design_balancer([50, 30, 20], [100]);
            const [s, m] = count_devices(g.source);
            if (s !== 0 || m !== 1) {
                throw new Error(`Expected 0S + 1M, got ${s}S + ${m}M`);
            }
            return 'Basic merge test: 0 splitters, 1 merger';
        });

        test('test_split_and_merge: combined split and merge', () => {
            const g = design_balancer([120, 60], [90, 90]);
            const [s, m] = count_devices(g.source);
            if (s !== 1 || m !== 1) {
                throw new Error(`Expected 1S + 1M, got ${s}S + ${m}M`);
            }
            return 'Split and merge test: 1 splitter, 1 merger';
        });

        test('test_perfect_3way_split: perfect 3-way split with equal outputs', () => {
            const g = design_balancer([90], [30, 30, 30]);
            const [s, m] = count_devices(g.source);
            if (s !== 1 || m !== 0) {
                throw new Error(`Expected 1S + 0M, got ${s}S + ${m}M`);
            }
            
            // Verify it's actually a 3-way split (one splitter connected to all 3 outputs)
            if (!g.source.includes("S0 -> O0")) throw new Error("Missing S0 -> O0");
            if (!g.source.includes("S0 -> O1")) throw new Error("Missing S0 -> O1");
            if (!g.source.includes("S0 -> O2")) throw new Error("Missing S0 -> O2");
            
            return 'Perfect 3-way split: verified connections';
        });

        test('test_large_example: [480]*3 -> [45]*32', () => {
            const inputs = Array(3).fill(480);
            const outputs = Array(32).fill(45);
            const g = design_balancer(inputs, outputs);
            const [s, m] = count_devices(g.source);
            
            // With 3 inputs going to 32 outputs, each input feeds ~10-11 outputs
            // Optimal splits: for 11 outputs we need ceil((11-1)/2) = 5 splitters per input
            // So roughly 15 splitters total (actual may vary based on exact distribution)
            // The algorithm achieves 16 which is near optimal
            if (s !== 16 || m !== 2) {
                throw new Error(`Expected 16S + 2M, got ${s}S + ${m}M`);
            }
            return 'Large example: 16 splitters, 2 mergers';
        });

        test('test_optimal_split_counts: split counts are optimal for various output counts', () => {
            let results = [];
            for (let n = 2; n < 12; n++) {
                const g = design_balancer([n * 30], Array(n).fill(30));
                const [s, m] = count_devices(g.source);
                const optimal = Math.ceil((n - 1) / 2);
                
                if (s !== optimal || m !== 0) {
                    throw new Error(`N=${n}: Expected ${optimal}S + 0M, got ${s}S + ${m}M`);
                }
                results.push(`N=${n}: ${s} splitters (optimal)`);
            }
            return results.join(', ');
        });

        test('test_optimal_merge_counts: merge counts are optimal for various input counts', () => {
            let results = [];
            for (let n = 2; n < 12; n++) {
                const g = design_balancer(Array(n).fill(30), [n * 30]);
                const [s, m] = count_devices(g.source);
                const optimal = Math.ceil((n - 1) / 2);
                
                if (s !== 0 || m !== optimal) {
                    throw new Error(`N=${n}: Expected 0S + ${optimal}M, got ${s}S + ${m}M`);
                }
                results.push(`N=${n}: ${m} mergers (optimal)`);
            }
            return results.join(', ');
        });

        test('test_feasibility_check: mismatched flows are rejected', () => {
            try {
                design_balancer([100], [90]);
                throw new Error('Should have raised error for mismatched flows');
            } catch (e) {
                if (!e.message.includes('must equal')) {
                    throw new Error('Wrong error message: ' + e.message);
                }
            }
            return 'Feasibility check: correctly rejects mismatched flows';
        });

        test('test_direct_connection: direct connection when possible', () => {
            const g = design_balancer([100], [100]);
            const [s, m] = count_devices(g.source);
            if (s !== 0 || m !== 0) {
                throw new Error(`Expected 0S + 0M for direct connection, got ${s}S + ${m}M`);
            }
            if (!g.source.includes("I0 -> O0")) {
                throw new Error("Missing direct I0 -> O0 connection");
            }
            return 'Direct connection: 0 devices, I0 -> O0';
        });

        test('test_graph_structure: graph has proper structure with colored nodes', () => {
            const g = design_balancer([120, 60], [90, 90]);
            const source = g.source;
            
            if (!source.includes("fillcolor=lightgreen")) {
                throw new Error("Missing green input nodes");
            }
            if (!source.includes("fillcolor=lightblue")) {
                throw new Error("Missing blue output nodes");
            }
            if (!source.includes("fillcolor=lightyellow")) {
                throw new Error("Missing yellow splitter nodes");
            }
            if (!source.includes("fillcolor=lightcoral")) {
                throw new Error("Missing coral merger nodes");
            }
            if (!source.includes("rankdir=LR")) {
                throw new Error("Missing LR layout");
            }
            
            return 'Graph structure: all node colors and layout verified';
        });

        test('test_complex_routing: complex routing scenario', () => {
            // 2 inputs to 5 outputs requires splits and merges
            const g = design_balancer([150, 150], [60, 60, 60, 60, 60]);
            const [s, m] = count_devices(g.source);
            
            // Each input feeds 2.5 outputs
            // Input 0 -> 3 outputs needs 1 splitter
            // Input 1 -> 3 outputs needs 1 splitter
            // Some outputs need mergers
            // Total should be around 2 splitters + some mergers
            if (s + m > 5) {
                throw new Error(`Expected <= 5 total devices, got ${s}S + ${m}M = ${s+m}`);
            }
            return `Complex routing: ${s} splitters + ${m} mergers = ${s+m} devices`;
        });

        test('test_two_way_split: simple 2-way split to cover edge cases', () => {
            const g = design_balancer([100], [50, 50]);
            const [s, m] = count_devices(g.source);
            if (s !== 1 || m !== 0) {
                throw new Error(`Expected 1S + 0M, got ${s}S + ${m}M`);
            }
            if (!g.source.includes("I0 -> S0")) {
                throw new Error("Missing I0 -> S0 connection");
            }
            if (!g.source.includes("S0 -> O0")) {
                throw new Error("Missing S0 -> O0 connection");
            }
            if (!g.source.includes("S0 -> O1")) {
                throw new Error("Missing S0 -> O1 connection");
            }
            return 'Two-way split: verified all connections';
        });

        test('test_single_source_output: single source to single output', () => {
            const g = design_balancer([80], [80]);
            const [s, m] = count_devices(g.source);
            if (!g.source.includes("I0 -> O0")) {
                throw new Error("Missing direct I0 -> O0 connection");
            }
            return 'Single source to output: direct connection verified';
        });

        // Display results
        const resultsDiv = document.getElementById('results');
        let passCount = 0;
        let failCount = 0;
        
        results.forEach(result => {
            const section = document.createElement('div');
            section.className = 'test-section';
            
            const status = result.status === 'pass' ? passCount++ : failCount++;
            const statusClass = result.status === 'pass' ? 'pass' : 'fail';
            
            section.innerHTML = `
                <h3 class="${statusClass}">${result.status.toUpperCase()}: ${result.name}</h3>
                <pre>${result.message}</pre>
                ${result.error ? `<pre style="color: red;">${result.error.stack}</pre>` : ''}
            `;
            
            resultsDiv.appendChild(section);
        });
        
        // Summary
        const summary = document.createElement('div');
        summary.style.cssText = 'font-size: 1.2em; padding: 20px; background: #ddd; margin-top: 20px;';
        summary.innerHTML = `
            <strong>Test Summary:</strong> 
            <span class="pass">${passCount} passed</span>, 
            <span class="fail">${failCount} failed</span>, 
            ${passCount + failCount} total
        `;
        resultsDiv.insertBefore(summary, resultsDiv.firstChild);
    </script>
</body>
</html>

