<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parsing Utils Test</title>
</head>
<body>
    <h1>Parsing Utils Test</h1>
    <div id="results"></div>

    <script type="module">
        import { parse_material_rate } from './parsing-utils.js';
        import {
            TestRunner,
            injectTestStyles,
            assertEquals,
            assertThrows
        } from './test-framework.js';

        // Inject common test styles
        injectTestStyles();
        
        // Create test runner
        const runner = new TestRunner();
        const test = (name, fn) => runner.test(name, fn);

        // Basic functionality tests
        test('parse_material_rate parses valid input', () => {
            const [material, rate] = parse_material_rate('Iron Ore:120');
            assertEquals(material, 'Iron Ore', 'Material name');
            assertEquals(rate, 120, 'Rate value');
            return `Parsed: ${material} at ${rate}/min`;
        });

        test('parse_material_rate trims whitespace', () => {
            const [material, rate] = parse_material_rate('  Copper Ore  :  60  ');
            assertEquals(material, 'Copper Ore', 'Material name trimmed');
            assertEquals(rate, 60, 'Rate value');
            return `Parsed: ${material} at ${rate}/min`;
        });

        test('parse_material_rate handles decimal rates', () => {
            const [material, rate] = parse_material_rate('Iron Plate:37.5');
            assertEquals(material, 'Iron Plate', 'Material name');
            assertEquals(rate, 37.5, 'Decimal rate value');
            return `Parsed: ${material} at ${rate}/min`;
        });

        test('parse_material_rate handles negative rates', () => {
            const [material, rate] = parse_material_rate('Coal:-30');
            assertEquals(material, 'Coal', 'Material name');
            assertEquals(rate, -30, 'Negative rate value');
            return `Parsed: ${material} at ${rate}/min`;
        });

        test('parse_material_rate throws on missing colon', () => {
            assertThrows(
                () => parse_material_rate('Iron Ore 120'),
                'Invalid format',
                'Should throw on missing colon'
            );
            return 'Correctly rejected missing colon';
        });

        test('parse_material_rate throws on invalid rate', () => {
            assertThrows(
                () => parse_material_rate('Iron Ore:abc'),
                'Invalid rate',
                'Should throw on non-numeric rate'
            );
            return 'Correctly rejected invalid rate';
        });

        test('parse_material_rate throws on empty rate', () => {
            assertThrows(
                () => parse_material_rate('Iron Ore:'),
                'Invalid rate',
                'Should throw on empty rate'
            );
            return 'Correctly rejected empty rate';
        });

        // ====================================================================
        // Tests ported from test_parsing_utils.py
        // ====================================================================

        test('test_parse_material_rate_basic: should parse basic Material:Rate strings', () => {
            const [material, rate] = parse_material_rate('Iron Ore:120');
            assertEquals(material, 'Iron Ore', 'Material equals Iron Ore');
            assertEquals(rate, 120.0, 'Rate equals 120.0');
            return `✓ Parsed: ${material} at ${rate}/min`;
        });

        test('test_parse_material_rate_with_spaces: should handle extra whitespace', () => {
            const [material, rate] = parse_material_rate('  Copper Ingot : 60.5  ');
            assertEquals(material, 'Copper Ingot', 'Material equals Copper Ingot');
            assertEquals(rate, 60.5, 'Rate equals 60.5');
            return `✓ Parsed with spaces: ${material} at ${rate}/min`;
        });

        test('test_parse_material_rate_float: should handle floating point rates', () => {
            const [material, rate] = parse_material_rate('Water:37.5');
            assertEquals(material, 'Water', 'Material equals Water');
            assertEquals(rate, 37.5, 'Rate equals 37.5');
            return `✓ Parsed float rate: ${material} at ${rate}/min`;
        });

        test('test_parse_material_rate_no_colon: should raise error without colon', () => {
            assertThrows(
                () => parse_material_rate('Iron Ore 120'),
                'Invalid format',
                'Should throw ValueError for missing colon'
            );
            return '✓ Correctly rejected missing colon';
        });

        test('test_parse_material_rate_invalid_rate: should raise error for non-numeric rate', () => {
            assertThrows(
                () => parse_material_rate('Iron Ore:not_a_number'),
                'Invalid rate',
                'Should throw ValueError for non-numeric rate'
            );
            return '✓ Correctly rejected non-numeric rate';
        });

        test('test_parse_material_rate_multiple_colons: should raise error when rate part contains colon', () => {
            // split(":", 1) splits only on first colon in Python
            // So "Material:With:Colon:100" becomes ("Material", "With:Colon:100")
            // And "With:Colon:100" will fail to parse as float
            assertThrows(
                () => parse_material_rate('Material:With:Colon:100'),
                'Invalid rate',
                'Should throw ValueError for multiple colons'
            );
            return '✓ Correctly rejected multiple colons in rate part';
        });

        test('test_parse_material_rate_complex_material_name: should handle complex material names', () => {
            const [material, rate] = parse_material_rate('Alternate Wet Concrete:240');
            assertEquals(material, 'Alternate Wet Concrete', 'Material equals Alternate Wet Concrete');
            assertEquals(rate, 240.0, 'Rate equals 240.0');
            return `✓ Parsed complex name: ${material} at ${rate}/min`;
        });

        test('test_parse_material_rate_zero: should handle zero rate', () => {
            const [material, rate] = parse_material_rate('Coal:0');
            assertEquals(material, 'Coal', 'Material equals Coal');
            assertEquals(rate, 0.0, 'Rate equals 0.0');
            return `✓ Parsed zero rate: ${material} at ${rate}/min`;
        });

        test('test_parse_material_rate_negative: should handle negative rates (consumption)', () => {
            const [material, rate] = parse_material_rate('Power:-100');
            assertEquals(material, 'Power', 'Material equals Power');
            assertEquals(rate, -100.0, 'Rate equals -100.0');
            return `✓ Parsed negative rate: ${material} at ${rate}/min`;
        });

        // Display results
        runner.displayResults();
    </script>
</body>
</html>

