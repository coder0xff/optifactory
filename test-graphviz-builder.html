<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphviz Builder Test</title>
</head>
<body>
    <h1>Graphviz Builder Test</h1>
    <div id="results"></div>

    <script type="module">
        import { Digraph, Subgraph } from './graphviz-builder.js';
        import {
            TestRunner,
            injectTestStyles,
            assertEquals,
            assertNotNull,
            assertTrue,
            assertContains,
            assertNotContains
        } from './test-framework.js';
        
        // Inject common test styles
        injectTestStyles();
        
        // Create test runner and initialize graphviz
        const runner = new TestRunner();
        await runner.initGraphviz();
        
        // Convenience wrappers
        const test = (name, fn) => runner.test(name, fn);
        const testWithGraph = (name, fn) => runner.test(name, fn);

        // ====================================================================
        // Basic structure tests
        // ====================================================================

        testWithGraph('Empty graph creates valid DOT', () => {
            const g = new Digraph();
            const source = g.source;
            assertContains(source, 'digraph G {', 'Contains digraph declaration');
            assertContains(source, '}', 'Contains closing brace');
            return { message: 'Empty graph is valid', graph: g };
        });

        testWithGraph('Graph with custom name', () => {
            const g = new Digraph('MyGraph');
            const source = g.source;
            assertContains(source, 'digraph MyGraph {', 'Contains custom name');
            return { message: 'Custom graph name works', graph: g };
        });

        testWithGraph('Graph attributes are included', () => {
            const g = new Digraph();
            g.attr({ rankdir: 'LR' });
            const source = g.source;
            assertContains(source, 'rankdir=LR', 'Contains rankdir attribute');
            return { message: 'Graph attributes work', graph: g };
        });

        testWithGraph('Multiple graph attributes', () => {
            const g = new Digraph();
            g.attr({ rankdir: 'LR', bgcolor: 'white' });
            const source = g.source;
            assertContains(source, 'rankdir=LR', 'Contains rankdir');
            assertContains(source, 'bgcolor=white', 'Contains bgcolor');
            return { message: 'Multiple graph attributes work', graph: g };
        });

        // ====================================================================
        // Node tests
        // ====================================================================

        testWithGraph('Simple node with no attributes', () => {
            const g = new Digraph();
            g.node('A', 'Node A');
            const source = g.source;
            assertContains(source, 'A [label="Node A"]', 'Node with label');
            return { message: 'Simple node works', graph: g };
        });

        testWithGraph('Node with empty label', () => {
            const g = new Digraph();
            g.node('A', '');
            const source = g.source;
            assertContains(source, 'A', 'Node ID present');
            assertContains(source, 'label=""', 'Empty label attribute present');
            return { message: 'Node with empty label works', graph: g };
        });

        testWithGraph('Node with no label parameter', () => {
            const g = new Digraph();
            g.node('A');
            const source = g.source;
            assertContains(source, 'A', 'Node ID present');
            assertNotContains(source, 'label=', 'No label attribute when not specified');
            return { message: 'Node with no label works', graph: g };
        });

        testWithGraph('Node with shape attribute', () => {
            const g = new Digraph();
            g.node('A', 'Node A', { shape: 'box' });
            const source = g.source;
            assertContains(source, 'shape=box', 'Contains shape');
            return { message: 'Node shape attribute works', graph: g };
        });

        testWithGraph('Node with multiple attributes', () => {
            const g = new Digraph();
            g.node('A', 'Input', { shape: 'box', style: 'filled', fillcolor: 'lightgreen' });
            const source = g.source;
            assertContains(source, 'label="Input"', 'Contains label');
            assertContains(source, 'shape=box', 'Contains shape');
            assertContains(source, 'style=filled', 'Contains style');
            assertContains(source, 'fillcolor=lightgreen', 'Contains fillcolor');
            return { message: 'Node with multiple attributes works', graph: g };
        });

        testWithGraph('Multiple nodes', () => {
            const g = new Digraph();
            g.node('A', 'Node A');
            g.node('B', 'Node B');
            g.node('C', 'Node C');
            const source = g.source;
            assertContains(source, 'A [label="Node A"]', 'Contains node A');
            assertContains(source, 'B [label="Node B"]', 'Contains node B');
            assertContains(source, 'C [label="Node C"]', 'Contains node C');
            return { message: 'Multiple nodes work', graph: g };
        });

        testWithGraph('Node with newline in label', () => {
            const g = new Digraph();
            g.node('A', 'Line 1\nLine 2');
            const source = g.source;
            assertContains(source, 'label="Line 1\\nLine 2"', 'Label with newline escaped');
            return { message: 'Node label with newline works', graph: g };
        });

        // ====================================================================
        // Edge tests
        // ====================================================================

        testWithGraph('Simple edge with no attributes', () => {
            const g = new Digraph();
            g.node('A', 'Node A');
            g.node('B', 'Node B');
            g.edge('A', 'B');
            const source = g.source;
            assertContains(source, 'A -> B', 'Contains edge');
            return { message: 'Simple edge works', graph: g };
        });

        testWithGraph('Edge with label', () => {
            const g = new Digraph();
            g.edge('A', 'B', { label: '100' });
            const source = g.source;
            assertContains(source, 'A -> B [label="100"]', 'Edge with label');
            return { message: 'Edge label works', graph: g };
        });

        testWithGraph('Edge with multiple attributes', () => {
            const g = new Digraph();
            g.edge('A', 'B', { label: 'Iron', color: 'red', style: 'bold' });
            const source = g.source;
            assertContains(source, 'A -> B', 'Contains edge');
            assertContains(source, 'label="Iron"', 'Contains label');
            assertContains(source, 'color="red"', 'Contains color');
            assertContains(source, 'style="bold"', 'Contains style');
            return { message: 'Edge with multiple attributes works', graph: g };
        });

        testWithGraph('Multiple edges', () => {
            const g = new Digraph();
            g.edge('A', 'B', { label: '10' });
            g.edge('B', 'C', { label: '20' });
            g.edge('C', 'A', { label: '30' });
            const source = g.source;
            assertContains(source, 'A -> B [label="10"]', 'Contains A -> B');
            assertContains(source, 'B -> C [label="20"]', 'Contains B -> C');
            assertContains(source, 'C -> A [label="30"]', 'Contains C -> A');
            return { message: 'Multiple edges work', graph: g };
        });

        testWithGraph('Edge with numeric label zero', () => {
            const g = new Digraph();
            g.edge('A', 'B', { label: 0 });
            const source = g.source;
            assertContains(source, 'label=0', 'Label 0 is included (numeric, not quoted)');
            return { message: 'Edge with label 0 works', graph: g };
        });

        // ====================================================================
        // Complete graph tests
        // ====================================================================

        testWithGraph('Complete graph with nodes, edges, and attributes', () => {
            const g = new Digraph('Factory');
            g.attr({ rankdir: 'LR' });
            g.node('Input', 'Iron Ore', { shape: 'box', fillcolor: 'orange' });
            g.node('Machine', 'Smelter', { shape: 'box', fillcolor: 'lightblue' });
            g.node('Output', 'Iron Ingot', { shape: 'box', fillcolor: 'lightgreen' });
            g.edge('Input', 'Machine', { label: '30' });
            g.edge('Machine', 'Output', { label: '30' });
            
            const source = g.source;
            assertContains(source, 'digraph Factory', 'Has graph name');
            assertContains(source, 'rankdir=LR', 'Has graph attribute');
            assertContains(source, 'Input', 'Has input node');
            assertContains(source, 'Machine', 'Has machine node');
            assertContains(source, 'Output', 'Has output node');
            assertContains(source, 'Input -> Machine', 'Has first edge');
            assertContains(source, 'Machine -> Output', 'Has second edge');
            
            return { message: 'Complete graph works', graph: g };
        });

        testWithGraph('Graph matches balancer use case', () => {
            const g = new Digraph();
            g.attr({ rankdir: 'LR' });
            g.node('I0', 'Input 0', { shape: 'box', style: 'filled', fillcolor: 'lightgreen' });
            g.node('O0', 'Output 0', { shape: 'box', style: 'filled', fillcolor: 'lightblue' });
            g.node('S0', '', { shape: 'diamond', style: 'filled', fillcolor: 'lightyellow' });
            g.edge('I0', 'S0', { label: '100' });
            g.edge('S0', 'O0', { label: '50' });
            
            const source = g.source;
            assertContains(source, 'rankdir=LR', 'Has LR direction');
            assertContains(source, 'shape=box', 'Has box shapes');
            assertContains(source, 'shape=diamond', 'Has diamond shape');
            assertContains(source, 'fillcolor=lightgreen', 'Has green color');
            assertContains(source, 'I0 -> S0', 'Has input to splitter edge');
            
            return { message: 'Balancer-style graph works', graph: g };
        });

        testWithGraph('Source property returns string', () => {
            const g = new Digraph();
            g.node('A', 'Node A');
            const source = g.source;
            assertTrue(typeof source === 'string', 'Source is a string');
            assertTrue(source.length > 0, 'Source is not empty');
            return { message: 'Source property type is correct', graph: g };
        });

        testWithGraph('Source property can be called multiple times', () => {
            const g = new Digraph();
            g.node('A', 'Node A');
            const source1 = g.source;
            const source2 = g.source;
            assertTrue(source1 === source2, 'Multiple calls return same result');
            return { message: 'Source property is stable', graph: g };
        });

        testWithGraph('Edge with penwidth attribute', () => {
            const g = new Digraph();
            g.edge('A', 'B', { penwidth: '2' });
            const source = g.source;
            assertContains(source, 'penwidth="2"', 'Edge has penwidth');
            return { message: 'Edge penwidth attribute works', graph: g };
        });

        testWithGraph('Edge with color containing colon (stripe colors)', () => {
            const g = new Digraph();
            g.edge('A', 'B', { color: 'black:white:black' });
            const source = g.source;
            assertContains(source, 'color="black:white:black"', 'Edge has color with colons');
            return { message: 'Edge stripe color works', graph: g };
        });

        testWithGraph('Edge with newline in label', () => {
            const g = new Digraph();
            g.edge('A', 'B', { label: 'Iron Ore\n100' });
            const source = g.source;
            assertContains(source, 'label="Iron Ore\\n100"', 'Edge label with newline escaped');
            return { message: 'Edge label with newline works', graph: g };
        });

        // ====================================================================
        // Subgraph tests
        // ====================================================================

        testWithGraph('Simple subgraph with callback', () => {
            const g = new Digraph();
            g.subgraph('cluster_0', (sub) => {
                sub.node('A', 'Node A');
            });
            const source = g.source;
            assertContains(source, 'subgraph cluster_0', 'Contains subgraph');
            assertContains(source, 'A [label="Node A"]', 'Contains node in subgraph');
            return { message: 'Simple subgraph with callback works', graph: g };
        });

        testWithGraph('Subgraph without callback (imperative)', () => {
            const g = new Digraph();
            const sub = g.subgraph('cluster_0');
            sub.node('A', 'Node A');
            const source = g.source;
            assertContains(source, 'subgraph cluster_0', 'Contains subgraph');
            assertContains(source, 'A [label="Node A"]', 'Contains node in subgraph');
            return { message: 'Imperative subgraph creation works', graph: g };
        });

        testWithGraph('Subgraph with label attribute', () => {
            const g = new Digraph();
            g.subgraph('cluster_0', (sub) => {
                sub.attr({ label: 'My Cluster' });
                sub.node('A', 'Node A');
            });
            const source = g.source;
            assertContains(source, 'label="My Cluster"', 'Subgraph has label');
            return { message: 'Subgraph label attribute works', graph: g };
        });

        testWithGraph('Subgraph with single attr call', () => {
            const g = new Digraph();
            const sub = g.subgraph('cluster_0');
            sub.attr('rank', 'same');
            sub.node('A', 'Node A');
            const source = g.source;
            assertContains(source, 'rank="same"', 'Subgraph has rank attribute');
            return { message: 'Subgraph single attr() works', graph: g };
        });

        testWithGraph('Subgraph with style and fillcolor', () => {
            const g = new Digraph();
            g.subgraph('cluster_0', (sub) => {
                sub.attr({ style: 'filled', fillcolor: 'lightblue' });
                sub.node('A', 'Node A');
            });
            const source = g.source;
            assertContains(source, 'style="filled"', 'Has style');
            assertContains(source, 'fillcolor="lightblue"', 'Has fillcolor');
            return { message: 'Subgraph style and fillcolor work', graph: g };
        });

        testWithGraph('Subgraph with empty label', () => {
            const g = new Digraph();
            g.subgraph('cluster_outputs', (sub) => {
                sub.attr({ label: '', style: 'invis' });
            });
            const source = g.source;
            assertContains(source, 'label=""', 'Empty label is quoted');
            assertContains(source, 'style="invis"', 'Has invisible style');
            return { message: 'Subgraph with empty label works', graph: g };
        });

        testWithGraph('Nested subgraphs', () => {
            const g = new Digraph();
            g.subgraph('cluster_outer', (outer) => {
                outer.attr({ label: 'Outer' });
                outer.node('A', 'Node A');
                outer.subgraph('cluster_inner', (inner) => {
                    inner.attr({ label: 'Inner' });
                    inner.node('B', 'Node B');
                });
            });
            const source = g.source;
            assertContains(source, 'subgraph cluster_outer', 'Has outer subgraph');
            assertContains(source, 'subgraph cluster_inner', 'Has inner subgraph');
            assertContains(source, 'label="Outer"', 'Has outer label');
            assertContains(source, 'label="Inner"', 'Has inner label');
            return { message: 'Nested subgraphs work', graph: g };
        });

        testWithGraph('Subgraph with edges', () => {
            const g = new Digraph();
            const sub = g.subgraph('cluster_0');
            sub.node('A', 'Node A');
            sub.node('B', 'Node B');
            sub.edge('A', 'B', { label: '10' });
            const source = g.source;
            assertContains(source, 'A -> B [label="10"]', 'Subgraph contains edge');
            return { message: 'Subgraph with edges works', graph: g };
        });

        testWithGraph('Multiple subgraphs', () => {
            const g = new Digraph();
            g.subgraph('cluster_0', (sub) => {
                sub.attr({ label: 'First' });
                sub.node('A', 'Node A');
            });
            g.subgraph('cluster_1', (sub) => {
                sub.attr({ label: 'Second' });
                sub.node('B', 'Node B');
            });
            const source = g.source;
            assertContains(source, 'cluster_0', 'Has first cluster');
            assertContains(source, 'cluster_1', 'Has second cluster');
            assertContains(source, 'label="First"', 'Has first label');
            assertContains(source, 'label="Second"', 'Has second label');
            return { message: 'Multiple subgraphs work', graph: g };
        });

        testWithGraph('Factory-style graph with clusters', () => {
            const g = new Digraph('Factory');
            g.attr({ rankdir: 'LR' });
            
            // Inputs subgraph
            g.subgraph('inputs', (inputs) => {
                inputs.attr('rank', 'same');
                inputs.node('Input_0', 'Iron Ore\n120/min', { 
                    shape: 'box', 
                    style: 'filled', 
                    fillcolor: 'orange' 
                });
            });
            
            // Machine cluster
            g.subgraph('cluster_0', (cluster) => {
                cluster.attr({ 
                    label: 'Smelter - Iron Ingot\nIron Ore:30\nâ†’ Iron Ingot:30',
                    style: 'filled',
                    fillcolor: 'lightblue'
                });
                cluster.node('Machine_0', '', { shape: 'box', style: 'filled', fillcolor: 'white' });
            });
            
            // Edge with color and penwidth
            g.edge('Input_0', 'Machine_0', { 
                label: 'Iron Ore\n30', 
                color: 'black:white:black',
                penwidth: '2'
            });
            
            const source = g.source;
            assertContains(source, 'digraph Factory', 'Has graph name');
            assertContains(source, 'rankdir=LR', 'Has rankdir');
            assertContains(source, 'subgraph inputs', 'Has inputs subgraph');
            assertContains(source, 'subgraph cluster_0', 'Has machine cluster');
            assertContains(source, 'rank="same"', 'Has rank attribute');
            assertContains(source, 'label="Smelter', 'Has cluster label');
            assertContains(source, 'penwidth="2"', 'Has edge penwidth');
            assertContains(source, 'color="black:white:black"', 'Has stripe color');
            
            return { message: 'Factory-style graph with all features works', graph: g };
        });

        testWithGraph('Node IDs with spaces are properly quoted', () => {
            const g = new Digraph();
            g.node('Iron Ore', 'Raw Material', { shape: 'box' });
            g.node('Iron Plate', 'Product', { shape: 'box' });
            g.edge('Iron Ore', 'Iron Plate', { label: '30' });
            
            const source = g.source;
            assertContains(source, '"Iron Ore"', 'Node ID with space is quoted');
            assertContains(source, '"Iron Plate"', 'Node ID with space is quoted');
            assertContains(source, '"Iron Ore" -> "Iron Plate"', 'Edge uses quoted IDs');
            
            return { message: 'Node IDs with spaces are properly quoted', graph: g };
        });

        testWithGraph('Special characters are properly escaped', () => {
            const g = new Digraph();
            g.node('A', 'Test\nNewline\tTab\\Backslash"Quote');
            const source = g.source;
            assertContains(source, '\\n', 'Newline is escaped');
            assertContains(source, '\\t', 'Tab is escaped');
            assertContains(source, '\\\\', 'Backslash is escaped');
            assertContains(source, '\\"', 'Quote is escaped');
            
            return { message: 'Special characters are properly escaped', graph: g };
        });

        // Display results
        runner.displayResults();
    </script>
</body>
</html>

